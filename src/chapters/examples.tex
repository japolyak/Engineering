\newpage
\section{Przykłady}

\subsection{Modelowanie układów ramowych}

\subsection{Implementacja obliczeń}
\subsubsection{Konfiguracja środowiska}

Aby móc zacząć pracę z silnikiem obliczeniowym \textbf{OpenSees} niezbędne jest prawidłowe skonfigurowanie środowiska programistycznego.
%TODO - add hiperlinks
Ze względu na to, iż komputery nie mają wbudowanego języka Python, ów należy pobrać z oficjalnej strony[1].
Postanowiono pobrać Python wersji 3.11, ponieważ biblioteka \textbf{OpenSeesPy} w wersji 3.5.1.12 akurat tego wymaga,
oraz darmowy edytor kodu źródłowego – \textbf{Visual Studio Code}[2], dla wygody napisana kodu.

Po udanej instalacji Pythona stworzono katalog projektu.
Następnie, korzystając z wiersza poleceń, wybrano wcześniej stworzony katalog i wykonano następne polecenia:

\begin{lstlisting}
python3 -m venv venv
source venv/bin/activate
\end{lstlisting}

W wyniku w wybranym katalogu powstało wirtualne środowisko o nazwie \textbf{venv} w celu odizolować zależności projektu.
Następnie dodano pliki o rozszerzeniu \textbf{.py} dla każdej konstrukcji oraz jeden plik pomocniczy, zawierający wspólny
dla każdego procesu obliczeniowego kod.
Na tym etapie kończy się konfiguracja środowiska.

\subsubsection{Instalacja i import modułów}

Korzystając z wiersza poleceń i komendy \inlinecode{pip install <module name>} zainstalowano następujące biblioteki:

\begin{itemize}
    \item OpenSeesPy
    \item OpsVis
    \item SciPy
    \item NumPy
    \item MatPlotLib
\end{itemize}

Po udanej instalacji przy pomocy komendy \textbf{import} zaimportowano moduły do każdego pliku:

\begin{lstlisting}
# Plik shared.py
import numpy as np
import opsvis as opsv
import matplotlib.pyplot as plt
import openseespy.opensees as ops
\end{lstlisting}

\begin{lstlisting}
# Pliki belka.py, kratownica.py, rama.py, konstrukcja_pretowa.py
import numpy as np
from scipy.stats import norm
from shared import show_results
import openseespy.opensees as ops
\end{lstlisting}

\subsubsection{Tworzenie modelu obliczeniowego}

Definicję modelu obliczeniowego wykonano poprzez wywołanie komendy
\inlinecode{model('basic', '-ndm', ndm, '-ndf', ndf)}, w którą po kolei przekazano następujące parametry:

\begin{itemize}
    \item liczbę wymiarów modelu \textbf{ndm} (1, 2, 3)
    \item liczbę stopni swobody na węźle \textbf{ndf}
\end{itemize}

Ponieważ analizowano układy dwuwymiarowe, wartość parametru \textbf{ndm} została ustawiona na 2.
Natomiast wartość \textbf{ndf} różniła się w zależności od typu konstrukcji:
\begin{itemize}
    \item kratownica i konstrukcja prętowa – ustawiono na 2 (dwa stopnie translacyjne)
    \item belka i rama przestrzenna – ustawiono na 3 (dwa stopnie translacyjne oraz jeden stopień rotacyjny)
\end{itemize}
Modele kratownicy i konstrukcji prętowej zdefiniowano jako:
\begin{lstlisting}
ops.model('basic', '-ndm', 2, '-ndf', 2)
\end{lstlisting}
Modele belki i ramy przestrzennej zdefiniowano jako:
\begin{lstlisting}
ops.model('basic', '-ndm', 2, '-ndf', 3)
\end{lstlisting}

\subsubsection{Definiowanie parametrów}

Ponieważ każda konstrukcja oraz elementy, z których ona się składa, mają swoje parametry, w celu ułatwić dalszą pracę z parametrami
je zdefiniowano jako zmienne.
Poniżej przedstawiono przykład zdefiniowania parametrów dla ramy przestrzennej:

\begin{lstlisting}
b = 0.3
d = 2.0 * b
A = b * d
I_z = (b * d ** 3) / 12
E = 30.0e6
\end{lstlisting}

Definicje niektórych parametrów są zależne od innych, np. pole przekroju \textbf{A} albo moment bezwładności \textbf{$I_z$}.
Także definiując niektóre parametry została użyta specyficzna składnia języka Python, np. zapis \inlinecode{e6} oznacza mnożenie
przez \textbf{$10^6$}, a zapis \inlinecode{**} oznacza potęgowanie.
Zdefiniowane dla każdej konstrukcji parametry przedstawiono w tabelach niniejszego rozdziału.

\begin{table}[!htbp]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
        \hline
        $a$ & $b$ & $c$ & $E_1$ & $E_2$ & $E_3$ & $A_1$ & $A_2$ & $A_3$ & $P_x$ & $P_y$ \\
        \hline
        \multicolumn{3}{|c|}{$m$} & \multicolumn{3}{|c|}{$X$} & \multicolumn{3}{|c|}{$m^2$} & \multicolumn{2}{|c|}{$kN$} \\
        \hline
        3 & 4 & 5 & $30*10^6$ & $40*10^6$ & $50*10^6$ & 0.3 & 0.2 & 0.1 & 15 & -5 \\
        \hline
    \end{tabular}
    \caption{Parametry konstrukcji prętowej}
    \label{tab:pars-kp}
\end{table}

\begin{table}[!htbp]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
        \hline
        $L$ & $H$ & $b$ & $d$ & $A$ & $I_z$ & $E$ & $P_1$ & $P_2$ \\
        \hline
        \multicolumn{4}{|c|}{$m$} & $m^2$ & $m^4$ & $X$ & \multicolumn{2}{|c|}{$kN$} \\
        \hline
        3 & 4 & 0.3 & 0.6 & 0.18 & $145.8*10^-6$ & $30*10^6$ & 150 & -50 \\
        \hline
    \end{tabular}
    \caption{Parametry ramy przestrzennej}
    \label{tab:pars-rama}
\end{table}

\begin{table}[!htbp]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
        \hline
        $L$ & $b$ & $d$ & $A$ & $I_z$ & $E$ & $P$ & $q$ \\
        \hline
        \multicolumn{3}{|c|}{$m$} & $m^2$ & $m^4$ & $X$ & $kN$ & $kN/m$ \\
        \hline
        3 & 0.3 & 0.6 & 0.18 & $145.8*10^-6$ & $30*10^6$ & -10 & -5 \\
        \hline
    \end{tabular}
    \caption{Parametry belki}
    \label{tab:pars-belka}
\end{table}

\begin{table}[!htbp]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        $a$ & $b$ & $A$ & $E$ & $P_x$ & $P_y$ \\
        \hline
        \multicolumn{2}{|c|}{$m$} & $m^2$ & $X$ & \multicolumn{2}{|c|}{$kN$} \\
        \hline
        3 & 3 & 0.2 & $30*10^6$ & 5 & -10 \\
        \hline
    \end{tabular}
    \caption{Paramtery kratownicy}
    \label{tab:pars-kratownica}
\end{table}

\subsubsection{Definiowanie węzłów i podpór}

Ze względu na to, że silnik obliczeniowy \textbf{OpenSeesPy} nie posiada wbudowanych narzędzi graficznych do rysowania
modelu konstrukcji oraz jej elementów, proces definiowania odbywał się w sposób manualny.
Aby stworzyć węzły, wywołano komendę \inlinecode{node(nodeTag, *crds)} (definicja skrócona), gdzie:

\begin{itemize}
    \item \textbf{nodeTag} – unikalny numer węzła w obrębie modelu (liczba całkowita)
    \item \textbf{crds} – lista współrzędnych węzła (lista liczb zmiennoprzecinkowych). Ilość współrzędnych zależna jest od wcześniej zdefiniowanego parametru \textbf{ndm}.
\end{itemize}

Do tworzenia podpór użyto komendy \inlinecode{fix(nodeTag, *constrValues)}, gdzie:

\begin{itemize}
    \item \textbf{nodeTag} – numer węzła danego modelu, którego dotyczy podpora (liczba całkowita)
    \item \textbf{constrValues} – lista wartości określających stany stopni swobody. Ilość wartości zależna jest od wcześniej zdefiniowanego parametru \textbf{ndf}. Możliwe wartości:
    \begin{itemize}
        \item 0 – brak zablokowania
        \item 1 – zablokowanie
    \end{itemize}
\end{itemize}

Dla listy \inlinecode{constrValues} jest ważna kolejność elementów, ponieważ położenie wartości w liście odpowiada stopniu swobody węzła:
\begin{itemize}
    \item pierwszy element – stopień swobody w kierunku osi X
    \item drugi element – stopień swobody w kierunku osi Y
    \item trzeci element – obrót wokół osi Z
\end{itemize}

W języku Python użycie operatora \inlinecode{*} przed listą elementów służy do przekazywania elementów tej listy jako argumentów funkcji.
Dla węzła o numerze 1 w punkcie (0.0, 0.0) definicja \inlinecode{ops.node(1, *(0.0, 0.0))} jest równoznaczna \inlinecode{ops.node(1, 0.0, 0.0)}.
W celu utrzymania jednolitości z dokumentacją \textbf{OpenSeesPy}, zdecydowano się na użycie operatora \inlinecode{*} w całym projekcie.
Przykładowa definicja węzłów i podpór dla ramy przestrzennej jest przedstawiona jako:

\begin{lstlisting}
ops.node(1, *(0.0, 0.0))
ops.node(2, *(L, 0.0))
ops.node(3, *(0, H))
ops.node(4, *(L, H))

ops.fix(1, *(1, 1, 0))
ops.fix(2, *(1, 1, 1))
\end{lstlisting}

\subsubsection{Definiowanie elementów}

Proces definiowania elementów konstrukcji zaczyna się wywołaniem odpowiedniej komendy, ustalającej właściwości elementów konstrukcyjnych.

\subsubsection*{Belka i rama przestrzenna}

Wychodząc z założeń dotyczących badanych konstrukcji, dla belki i ramy przestrzennej \inlinecode{geomTransf(transfType, transfTag)} (definicja skrócona).
Ta komenda służy do transformacji sztywności elementu belki i siły oporu z układu podstawowego do globalnego układu współrzędnych[https://openseespydoc.readthedocs.io/en/latest/src/geomTransf.html].
Przekazywanymi parametrami są:

\begin{itemize}
    \item \textbf{transfType} – typ transformacji – zakłada się liniowa transformacja ('Linear')
    \item \textbf{transfTag} – unikalny numer transformacji (liczba całkowita)
\end{itemize}

Wywołanie komendy dla konstrukcji ma następującą postać:

\begin{lstlisting}
ops.geomTransf('Linear', 1)
\end{lstlisting}

\subsubsection*{Kratownica i konstrukcja prętowa}

Inaczej wygląda sytuacja dla kratownicy i konstrukcji prętowej.
Zakłada się, iż to są konstrukcje prętowe, dla których jest analizowane zachowanie w zależności od wartości materiałowych.
Wychodząc z tego założenia, dla tych konstrukcji wywołano komendę \inlinecode{uniaxialMaterial(matType, matTag, *matArgs)},
tworzy obiekt reprezentujący jednoosiowe zależności naprężenie-odkształcenie (lub siła odkształcenie).
Przekazywane parametry to:

\begin{itemize}
    \item \textbf{matType} – typ materiału - zakłada się materiał jest sprężysty ('Elastic')
    \item \textbf{matTag} – unikalny numer materiału (liczba całkowita)
    \item \textbf{matArgs} – lista argumentów materiału. Ponieważ materiał jest elastyczny, wystarczy przekazać tylko moduł Younga \textbf{E} (liczba zmiennoprzecinkowa)
\end{itemize}

Założono, że elementy kratownicy są wykonane z jednorodnego materiału o takim samym przekroju, dlatego został zdefiniowany jeden materiał

\begin{lstlisting}
ops.uniaxialMaterial('Elastic', 1, E)
\end{lstlisting}

Konstrukcja prętowa składa się z trzech prętów o różnych przekrojach i materiałach, dlatego zdefiniowano trzy materiały:

\begin{lstlisting}
ops.uniaxialMaterial('Elastic', 1, E_1)
ops.uniaxialMaterial('Elastic', 2, E_2)
ops.uniaxialMaterial('Elastic', 3, E_3)
\end{lstlisting}

\subsubsection*{Elementy konstrukcyjne}

Komendą odpowiadającą za tworzenie elementów konstrukcyjnych jest \inlinecode{element(eleType, eleTag, *eleNodes, *eleArgs)}, której parametry to:

\begin{itemize}
    \item \textbf{eleType} – typ elementu (wartość tekstowa)
    \item \textbf{eleTag} – unikalny numer elementu (liczba całkowita)
    \item \textbf{eleNodes} – lista węzłów elementu (lista liczb całkowitych)
    \item \textbf{eleArgs} – lista argumentów
\end{itemize}

Ponieważ silnik obliczeniowy \textbf{OpenSeesPy} uwzględnia różne typy elementów, każdemu typu odpowiada inna lista argumentów.
Belka oraz rama przestrzenna składają się z elementów belkowych, dlatego jako typ elementu przyjęto \inlinecode{'elasticBeamColumn'}, a
w dwuwymiarowym układzie współrzędnych skrócona definicja elementów ma postać:

\begin{lstlisting}
element('elasticBeamColumn', eleTag, *eleNodes, Area, Emod, Iz, transfTag)
\end{lstlisting}

gdzie argumentami są:
\begin{itemize}
    \item \textbf{Area} – pole przekroju elementu (liczba zmiennoprzecinkowa)
    \item \textbf{Emod} – moduł Younga materiału (liczba zmiennoprzecinkowa)
    \item \textbf{Iz} – moment bezwładności przekroju elementu (liczba zmiennoprzecinkowa)
    \item \textbf{transfTag} – numer transformacji (liczba całkowita)
\end{itemize}

Przykład definicji elementów dla ramy przestrzennej:

\begin{lstlisting}
ops.element('elasticBeamColumn', 1, 1, 3, A, E, I_z, 1)
ops.element('elasticBeamColumn', 2, 3, 4, A, E, I_z, 1)
ops.element('elasticBeamColumn', 3, 4, 2, A, E, I_z, 1)
\end{lstlisting}

Ponieważ kratownica i konstrukcja prętowa składają się z prętów, jako typ elementu przyjęto \inlinecode{'truss'}, a skrócona definicja elementów ma postać:

\begin{lstlisting}
element('truss', eleTag, *eleNodes, A, matTag)
\end{lstlisting}

gdzie argumentami są:
\begin{itemize}
    \item \textbf{A} – pole przekroju elementu (liczba zmiennoprzecinkowa)
    \item \textbf{matTag} – numer wcześniej zdefiniowanego materiału (liczba całkowita)
\end{itemize}

Przykład definicji elementów dla konstrukcji prętowej:

\begin{lstlisting}
ops.element('truss', 1, 1, 4, A_1, 1)
ops.element('truss', 2, 2, 4, A_2, 2)
ops.element('truss', 3, 3, 4, A_3, 3)
\end{lstlisting}

\subsubsection{Definiowanie obciążeń}

W ramach analizy wrażliwości konstrukcji będą rozpatrywane dwa rodzaje obciążeń – obciążenie siłą skupioną oraz siłą rozłożoną.

\subsubsection*{Siła skupiona}

Definiowanie siły skupionej zaczyna się od wywołania komendy \inlinecode{timeSeries(tsType, tsTag, *tsArgs)}, która
tworzy obiekt reprezentujący zależność pomiędzy czasem a współczynnikiem obciążenia zastosowanym do jednego ze zdefiniowanych
w schemacie obciążeń, z którym ten obiekt jest powiązany $\lambda=F(t)$.
Przekazywane parametry to:

\begin{itemize}
    \item \textbf{tsType} – typ szeregu czasowego. Ponieważ siła skupiona jest stała w czasie, przyjęto wartość \inlinecode{'Constant'}
    \item \textbf{tsTag} – unikalny numer szeregu czasowego (liczba całkowita)
    \item \textbf{tsArgs} – lista argumentów – opcjonalna, tak jak dla siły stałej współczynnik obciążenia równa się 1
\end{itemize}

Kolejną metodą, która tym razem odpowiada za tworzenie szablonu obciążenia, jest \inlinecode{pattern(patternType, patternTag, *patternArgs)}.
Każdy szablon powinien być powiązany z jednym zdefiniowanym wcześniej szeregiem czasowym.
Przekazywane parametry to:

\begin{itemize}
    \item \textbf{patternType} – typ szablonu obciążenia – dla siły skupionej przyjęto wartość \inlinecode{'Plain'}
    \item \textbf{patternTag} – unikalny numer szablonu obciążenia (liczba całkowita)
    \item \textbf{patternArgs} – lista argumentów – dla siły skupionej wystarczy przekazać numer szeregu czasowego
\end{itemize}

Ostatnią komendą, która odpowiada za przypisanie obciążenia do węzła, jest \inlinecode{load(nodeTag, *loadValues)},
której parametrami są:

\begin{itemize}
    \item \textbf{nodeTag} – numer węzła, do którego przypisane jest obciążenie (liczba całkowita)
    \item \textbf{loadValues} – lista wartości rzutów obciążenia na kierunkach X, Y oraz Z (lista liczb zmiennoprzecinkowych). Ilość wartości zależna jest od wcześniej zdefiniowanego parametru \textbf{ndf}
\end{itemize}

Przykład definicji obciążenia siłą skupioną w 4 węźle dla konsoli prętowej:
\begin{lstlisting}
ops.timeSeries('Constant', 1)
ops.pattern('Plain', 1, 1)
ops.load(4, P_x, P_y)
\end{lstlisting}

\subsubsection*{Siła rozłożona}

Mówiąc o sile rozłożonej, proces definiowania jest znacznie prostszy i mieści się w uproszczonej komendzie
\inlinecode{eleLoad('-ele', *eleTags, '-type', '-beamUniform', Wy)}, której należy przekazać:

\begin{itemize}
    \item \textbf{eleTags} – listę numerów elementów, dla których zostanie przypisane obciążenie (lista liczb całkowitych)
    \item \textbf{Wy} – wartość obciążenia w kierunku Y (liczba zmiennoprzecinkowa)
\end{itemize}

Przykład definicji obciążenia siłą rozłożoną w 1 elemencie belki:
\begin{lstlisting}
ops.eleLoad('-ele', 1, '-type', '-beamUniform', q)
\end{lstlisting}

\subsubsection{Parametryzacja modelu}

Proces parametryzacji zaczyna się od definicji zmiennej, która reprezentuje procentowe odchylenie od wartości nominalnej.
W ramach projektu przyjęto 10 \% odchylenie - \inlinecode{cov = 0.1}.

Następnie wywołanie komendy \inlinecode{ops.analysis('Static')} tworzy obiekt analityczny, który odpowiada za przeprowadzenie analizy statycznej.

\subsubsection{Przeprowadzenie obliczeń}

dfgdgdfg

\subsubsection{Prezentacja wyników}

dgdgdgdgd

\subsection{Optymalizacja kodu obliczeniowego}

dfgdfgdg
