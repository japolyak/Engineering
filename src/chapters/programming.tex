\subsection{Wprowadzenie progrmamistyczne}

\subsubsection{Konfiguracja środowiska}

Aby móc zacząć pracę z silnikiem obliczeniowym \textbf{OpenSees} niezbędne jest prawidłowe skonfigurowanie środowiska programistycznego.
%TODO - add hiperlinks
Ze względu na to, iż komputery nie mają wbudowanego języka Python, ów należy pobrać z oficjalnej strony[1].
Postanowiono pobrać Python wersji 3.11, ponieważ biblioteka \textbf{OpenSeesPy} w wersji 3.5.1.12 akurat tego wymaga,
oraz darmowy edytor kodu źródłowego – \textbf{Visual Studio Code}[2], dla wygody napisana kodu.

Po udanej instalacji Pythona stworzono katalog projektu.
Następnie, korzystając z wiersza poleceń, wybrano wcześniej stworzony katalog i wykonano następne polecenia:

\begin{lstlisting}
python3 -m venv venv
source venv/bin/activate
\end{lstlisting}

W wyniku w wybranym katalogu powstało wirtualne środowisko o nazwie \textbf{venv} w celu odizolować zależności projektu.
Następnie dodano pliki o rozszerzeniu \textbf{.py} dla każdej konstrukcji oraz jeden plik pomocniczy, zawierający wspólny
dla każdego procesu obliczeniowego kod.
Na tym etapie kończy się konfiguracja środowiska.

\subsubsection{Instalacja i import modułów}

Korzystając z wiersza poleceń i komendy \inlinecode{pip install <module name>} zainstalowano następujące biblioteki –
\textbf{OpenSeesPy}, \textbf{OpsVis}, \textbf{SciPy}, \textbf{NumPy} oraz \textbf{MatPlotLib}.

Po udanej instalacji przy pomocy komendy \textbf{import} zaimportowano moduły do każdego pliku:

\begin{lstlisting}
# Plik shared.py
import numpy as np
import opsvis as opsv
import matplotlib.pyplot as plt
import openseespy.opensees as ops
\end{lstlisting}

\begin{lstlisting}
# Pliki belka.py, kratownica.py, rama.py, konstrukcja_pretowa.py
import numpy as np
from scipy.stats import norm
from shared import show_results
import openseespy.opensees as ops
\end{lstlisting}

\subsubsection{Tworzenie modelu obliczeniowego}

Definicję modelu obliczeniowego wykonano poprzez wywołanie komendy
\inlinecode{model('basic', '-ndm', ndm, '-ndf', ndf)}, w którą po kolei przekazano następujące parametry:

\begin{itemize}
    \item liczbę wymiarów modelu \textbf{ndm} (1, 2, 3)
    \item liczbę stopni swobody na węźle \textbf{ndf}
\end{itemize}

Ponieważ analizowano układy dwuwymiarowe, wartość parametru \textbf{ndm} została ustawiona na 2.
Natomiast wartość \textbf{ndf} różniła się w zależności od typu konstrukcji:

\begin{itemize}
    \item 2 (2 stopnie translacyjne) – konstrukcja prętowa
    \item 3 (2 stopnie translacyjne oraz 1 stopień rotacyjny) – belka i rama przestrzenna
\end{itemize}

\subsubsection{Definiowanie parametrów}

Ponieważ każda konstrukcja oraz elementy, z których ona się składa, mają swoje parametry, w celu ułatwić dalszą pracę z parametrami
je zdefiniowano jako zmienne.
Poniżej przedstawiono przykład zdefiniowania parametrów dla ramy przestrzennej:

\begin{lstlisting}
b = 0.3
d = 2.0 * b
A = b * d
I_z = (b * d ** 3) / 12
E = 30.0e6
\end{lstlisting}

Definicje niektórych parametrów są zależne od innych, np. pole przekroju \textbf{A} albo moment bezwładności \textbf{$I_z$}.
Także definiując niektóre parametry została użyta specyficzna składnia języka Python, np. zapis \inlinecode{e6} oznacza mnożenie
przez \textbf{$10^6$}, a zapis \inlinecode{**} oznacza potęgowanie.

\subsubsection{Definiowanie węzłów i podpór}

Ze względu na to, że silnik obliczeniowy \textbf{OpenSeesPy} nie posiada wbudowanych narzędzi graficznych do rysowania
modelu konstrukcji oraz jej elementów, proces definiowania odbywał się w sposób manualny.
Aby stworzyć węzły, wywołano komendę \inlinecode{node(nodeTag, *crds)} (definicja skrócona), gdzie:

\begin{itemize}
    \item \textbf{nodeTag} – unikalny numer węzła w obrębie modelu (liczba całkowita)
    \item \textbf{crds} – lista współrzędnych węzła (lista liczb zmiennoprzecinkowych). Ilość współrzędnych zależna jest od wcześniej zdefiniowanego parametru \textbf{ndm}.
\end{itemize}

Do tworzenia podpór użyto komendy \inlinecode{fix(nodeTag, *constrValues)}, gdzie:

\begin{itemize}
    \item \textbf{nodeTag} – numer węzła danego modelu, którego dotyczy podpora (liczba całkowita)
    \item \textbf{constrValues} – lista wartości określających stany stopni swobody. Ilość wartości zależna jest odwcześniej zdefiniowanego parametru \textbf{ndf}, gdzie 1 oznaczna blokadę, a 0 brak blokady.
\end{itemize}

Dla listy \inlinecode{constrValues} jest ważna kolejność elementów, ponieważ położenie wartości w liście odpowiada stopniu swobody węzła:
\begin{itemize}
    \item pierwszy element – stopień swobody w kierunku osi X
    \item drugi element – stopień swobody w kierunku osi Y
    \item trzeci element – obrót wokół osi Z
\end{itemize}

W języku Python użycie operatora \inlinecode{*} przed listą elementów służy do przekazywania elementów tej listy jako argumentów funkcji.
Dla węzła o numerze 1 w punkcie (0.0, 0.0) definicja \inlinecode{ops.node(1, *(0.0, 0.0))} jest równoznaczna \inlinecode{ops.node(1, 0.0, 0.0)}.
W celu utrzymania jednolitości z dokumentacją \textbf{OpenSeesPy}, zdecydowano się na użycie operatora \inlinecode{*} w całym projekcie.
Przykładowa definicja węzłów i podpór dla ramy przestrzennej jest przedstawiona jako:

\begin{lstlisting}
ops.fix(1, *(1, 1, 0))
ops.fix(2, *(1, 1, 1))

ops.node(1, *(0.0, 0.0))
ops.node(2, *(L, 0.0))
ops.node(3, *(0, H))
ops.node(4, *(L, H))
\end{lstlisting}

\subsubsection{Definiowanie elementów}

Proces definiowania elementów konstrukcji zaczyna się wywołaniem odpowiedniej komendy, ustalającej właściwości elementów konstrukcyjnych.

\subsubsection*{Układy belkowe}

W układach belkowych proces definiowania elementów zaczyna sięwywołaniem komendy \inlinecode{geomTransf(transfType, transfTag)} (definicja skrócona),
która służy do definiowania transformacji geometrycznych elementów belek i kolumn, które pozwalają na uwzględnienie wpływu
deformacji na zachowanie struktury w analizach nieliniowych. Transformacja ta przekształca lokalny układ współrzędnych elementu na globalny układ współrzędnych, co jest kluczowe w przypadku analizy statycznej i dynamicznej struktur.
Przekazywanymi parametrami są:

\begin{itemize}
    \item \textbf{transfType} – typ transformacji – zakłada się liniowa transformacja ('Linear')
    \item \textbf{transfTag} – unikalny numer transformacji (liczba całkowita)
\end{itemize}

Wywołanie komendy dla konstrukcji ma następującą postać:

\begin{lstlisting}
ops.geomTransf('Linear', 1)
\end{lstlisting}

\subsubsection*{Układy prętowe}

W analizach układów prętowych, kluczowym aspektem jest ocena zachowania konstrukcji w zależności od właściwości materiałowych.
W tym kontekście, komenda  \inlinecode{uniaxialMaterial(matType, matTag, *matArgs)} służy do tworzenia obiektów reprezentujących
jednoosiowe zależności między naprężeniem a odkształceniem lub między siłą a odkształceniem.
Przekazywane parametry to:

\begin{itemize}
    \item \textbf{matType} – typ materiału - zakłada się materiał jest sprężysty ('Elastic')
    \item \textbf{matTag} – unikalny numer materiału (liczba całkowita)
    \item \textbf{matArgs} – lista argumentów materiału. Ponieważ materiał jest elastyczny, wystarczy przekazać tylko moduł Younga \textbf{E} (liczba zmiennoprzecinkowa)
\end{itemize}

Przykładowa definicja materiału elementu konstrukcji prętowej

\begin{lstlisting}
ops.uniaxialMaterial('Elastic', 1, E_1)
\end{lstlisting}

\subsubsection*{Elementy konstrukcyjne}

Komenda \inlinecode{element(eleType, eleTag, *eleNodes, *eleArgs)} odpowiada za tworzenie elementów konstrukcyjnych, parametrami której są:

\begin{itemize}
    \item \textbf{eleType} – typ elementu (wartość tekstowa)
    \item \textbf{eleTag} – unikalny numer elementu (liczba całkowita)
    \item \textbf{eleNodes} – lista węzłów elementu (lista liczb całkowitych)
    \item \textbf{eleArgs} – lista argumentów
\end{itemize}

Ponieważ silnik obliczeniowy \textbf{OpenSeesPy} uwzględnia różne typy elementów, każdemu typowi odpowiada inna lista argumentów.

Dla układów belkowych jako typ elementu przyjęto \inlinecode{'elasticBeamColumn'},dla którego skrócona definicja elementów w układzie dwuwymiarowym ma postać:

\begin{lstlisting}
element('elasticBeamColumn', eleTag, *eleNodes, Area, Emod, Iz, transfTag)
\end{lstlisting}
gdzie argumentami są:
\begin{itemize}
    \item \textbf{Area} – pole przekroju elementu (liczba zmiennoprzecinkowa)
    \item \textbf{Emod} – moduł Younga materiału (liczba zmiennoprzecinkowa)
    \item \textbf{Iz} – moment bezwładności przekroju elementu (liczba zmiennoprzecinkowa)
    \item \textbf{transfTag} – numer transformacji (liczba całkowita)
\end{itemize}
Przykład definicji elementu ramy przestrzennej:

\begin{lstlisting}
ops.element('elasticBeamColumn', 1, 1, 3, A, E, I_z, 1)
\end{lstlisting}
W układach prętowych jako typ elementu przyjmuje się \inlinecode{'truss'}, a skrócona definicja elementu ma postać:

\begin{lstlisting}
element('truss', eleTag, *eleNodes, A, matTag)
\end{lstlisting}
gdzie argumentami są:
\begin{itemize}
    \item \textbf{A} – pole przekroju elementu (liczba zmiennoprzecinkowa)
    \item \textbf{matTag} – numer wcześniej zdefiniowanego materiału (liczba całkowita)
\end{itemize}
Przykład definicji elementu konstrukcji prętowej:

\begin{lstlisting}
ops.element('truss', 1, 1, 4, A_1, 1)
\end{lstlisting}

\subsubsection{Definiowanie obciążeń}

W ramach analizy wrażliwości konstrukcji są rozpatrywane dwa rodzaje obciążeń – obciążenie siłą skupioną oraz siłą rozłożoną.

\subsubsection*{Obciążenie siłą skupioną}

Definiowanie siły skupionej zaczyna się od wywołania komendy, która tworzy obiekt reprezentujący zależność $\lambda=F(t)$ pomiędzy czasem
a współczynnikiem obciążenia zastosowanym do jednego ze zdefiniowanych w schemacie obciążeń, z którym ten obiekt jest powiązany – \inlinecode{timeSeries(tsType, tsTag, *tsArgs)}.
Przekazywane parametry to:

\begin{itemize}
    \item \textbf{tsType} – typ szeregu czasowego. Ponieważ siła skupiona jest stała w czasie, przyjęto wartość \inlinecode{'Constant'}
    \item \textbf{tsTag} – unikalny numer szeregu czasowego (liczba całkowita)
    \item \textbf{tsArgs} – lista argumentów – opcjonalna, tak jak dla siły stałej współczynnik obciążenia równa się 1
\end{itemize}
Komenda \inlinecode{pattern(patternType, patternTag, *patternArgs)} jest odpowiedzialna za tworzenie szablonu obciążenia.
Każdy szablon powinien być powiązany z jednym zdefiniowanym wcześniej szeregiem czasowym. Parametrami przekazywanymi są:

\begin{itemize}
    \item \textbf{patternType} – typ szablonu obciążenia – dla siły skupionej przyjęto wartość \inlinecode{'Plain'}
    \item \textbf{patternTag} – unikalny numer szablonu obciążenia (liczba całkowita)
    \item \textbf{patternArgs} – lista argumentów – dla siły skupionej wystarczy przekazać numer szeregu czasowego
\end{itemize}
Ostatnią komendą, która odpowiada za przypisanie obciążenia do węzła, jest \inlinecode{load(nodeTag, *loadValues)},
której parametrami są:

\begin{itemize}
    \item \textbf{nodeTag} – numer węzła, do którego przypisane jest obciążenie (liczba całkowita)
    \item \textbf{loadValues} – lista wartości rzutów obciążenia na kierunkach X, Y oraz Z (lista liczb zmiennoprzecinkowych). Ilość wartości zależna jest od wcześniej zdefiniowanego parametru \textbf{ndf}
\end{itemize}
Przykład definicji obciążenia siłą skupioną działającego na konstrukcję prętowej:
\begin{lstlisting}
ops.timeSeries('Constant', 1)
ops.pattern('Plain', 1, 1)
ops.load(4, P_x, P_y)
\end{lstlisting}

\subsubsection*{Obciązenie siłą rozłożoną}

Mówiąc o sile rozłożonej, proces definiowania jest znacznie prostszy i mieści się w jednej komendzie
\inlinecode{eleLoad('-ele', *eleTags, '-type', '-beamUniform', Wy)} (definicja skrócona), której należy przekazać:

\begin{itemize}
    \item \textbf{eleTags} – listę numerów elementów, dla których zostanie przypisane obciążenie (lista liczb całkowitych)
    \item \textbf{Wy} – wartość obciążenia w kierunku Y (liczba zmiennoprzecinkowa)
\end{itemize}

Przykład definicji obciążenia siłą rozłożoną w 1 elemencie belki:
\begin{lstlisting}
ops.eleLoad('-ele', 1, '-type', '-beamUniform', q)
\end{lstlisting}

\subsubsection{Parametryzacja modelu}

Proces parametryzacji w analizie konstrukcji zaczyna się od zdefiniowania zmiennej, która reprezentuje procentowe odchylenie
od wartości nominalnej. W ramach projektu przyjęto odchylenie wynoszące 10 \% – \inlinecode{cov = 0.1}.

Następnie, zprzy pomocy komendy \inlinecode{ops.analysis('Static')} tworzy się obiekt analityczny odpowiedzialny za przeprowadzenie
analizy statycznej. Komenda ta inicjalizuje analizator, który będzie stosował metody analizy statycznej do ocenienia zachowania konstrukcji w odpowiedzi na przyłożone obciążenia.

\subsubsection{Przeprowadzenie obliczeń}

dfgdgdfg

\subsubsection{Prezentacja wyników}

dgdgdgdgd
